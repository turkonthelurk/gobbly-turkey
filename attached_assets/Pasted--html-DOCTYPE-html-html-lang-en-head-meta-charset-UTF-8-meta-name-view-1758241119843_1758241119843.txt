```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gobbly Turkey - 3D Thanksgiving Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameOver"></div>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.0/+esm';
        import { FontLoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/loaders/FontLoader.js';
        import { TextGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/geometries/TextGeometry.js';

        // Constants
        const WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
        const TURKEY_SIZE = 0.5, TURKEY_X = 0, TURKEY_Z = -5;
        const GRAVITY = 0.01, FLAP_STRENGTH = -0.3;
        const TRUNK_RADIUS = 1, TRUNK_GAP = 4, TRUNK_SPEED = 0.1;
        const TRUNK_FREQUENCY = 2000; // milliseconds
        const AUTUMN_SKY = 0xff8c00, TURKEY_BODY = 0x8b4513, TURKEY_HEAD = 0xa0522d, WATTLE_RED = 0xdc143c, BLACK = 0x000000;
        const BARK_COLOR = 0x654321;

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, WIDTH / HEIGHT, 0.1, 1000);
        camera.position.set(0, 2, 10);
        camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(WIDTH, HEIGHT);
        document.body.appendChild(renderer.domElement);
        scene.background = new THREE.Color(AUTUMN_SKY);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Procedural bark texture (simple noise shader)
        const barkShader = {
            uniforms: {
                color: { value: new THREE.Color(BARK_COLOR) },
                noiseScale: { value: 0.5 },
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                uniform float noiseScale;
                uniform float time;
                varying vec2 vUv;
                float noise(vec2 p) {
                    return sin(p.x * 10.0) * sin(p.y * 10.0) * 0.5 + 0.5;
                }
                void main() {
                    float n = noise(vUv * noiseScale + time);
                    gl_FragColor = vec4(color * (0.8 + 0.4 * n), 1.0);
                }
            `
        };

        // Turkey class
        class Turkey {
            constructor() {
                this.group = new THREE.Group();
                // Body (ellipsoid)
                const bodyGeo = new THREE.SphereGeometry(TURKEY_SIZE, 32, 32);
                bodyGeo.scale(1.2, 0.8, 0.8);
                const bodyMat = new THREE.MeshPhongMaterial({ color: TURKEY_BODY, shininess: 10 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                this.group.add(body);
                // Head (sphere)
                const headGeo = new THREE.SphereGeometry(0.2, 32, 32);
                const headMat = new THREE.MeshPhongMaterial({ color: TURKEY_HEAD, shininess: 10 });
                this.head = new THREE.Mesh(headGeo, headMat);
                this.head.position.set(0.4, 0.2, 0);
                this.group.add(this.head);
                // Wattle (cone)
                const wattleGeo = new THREE.ConeGeometry(0.1, 0.2, 16);
                const wattleMat = new THREE.MeshPhongMaterial({ color: WATTLE_RED, shininess: 5 });
                const wattle = new THREE.Mesh(wattleGeo, wattleMat);
                wattle.position.set(0.4, 0.1, 0);
                wattle.rotation.x = Math.PI / 2;
                this.group.add(wattle);
                // Eye (small sphere)
                const eyeGeo = new THREE.SphereGeometry(0.05, 16, 16);
                const eyeMat = new THREE.MeshPhongMaterial({ color: BLACK, shininess: 100 });
                const eye = new THREE.Mesh(eyeGeo, eyeMat);
                eye.position.set(0.45, 0.25, 0.1);
                this.group.add(eye);
                // Wing (flattened box)
                const wingGeo = new THREE.BoxGeometry(0.3, 0.2, 0.1);
                const wingMat = new THREE.MeshPhongMaterial({ color: TURKEY_HEAD, shininess: 10 });
                this.wing = new THREE.Mesh(wingGeo, wingMat);
                this.wing.position.set(0, 0, 0.4);
                this.wing.rotation.set(0, 0, 0);
                this.group.add(this.wing);
                // Tail feathers (triangles)
                const tailGeo = new THREE.BufferGeometry();
                const vertices = new Float32Array([
                    -0.4, 0, 0, -0.6, 0.2, 0.1, -0.6, -0.2, 0.1,
                    -0.5, 0, 0, -0.7, 0.3, 0.2, -0.7, -0.1, 0.2,
                ]);
                tailGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                const tailMat = new THREE.MeshPhongMaterial({ color: TURKEY_BODY, shininess: 10, side: THREE.DoubleSide });
                const tail = new THREE.Mesh(tailGeo, tailMat);
                this.group.add(tail);
                this.group.position.set(TURKEY_X, 0, TURKEY_Z);
                scene.add(this.group);
                this.velocity = 0;
                this.flapAnimation = 0;
                this.bobTime = 0;
                this.boundingSphere = new THREE.Sphere(this.group.position, TURKEY_SIZE * 1.2); // Approximate sphere for collision
            }
            flap() {
                this.velocity = FLAP_STRENGTH;
                this.flapAnimation = 20; // Longer for rotation
            }
            update() {
                this.velocity += GRAVITY;
                this.group.position.y += this.velocity;

                // Wing flap animation with rotation
                if (this.flapAnimation > 0) {
                    const angle = Math.sin(this.flapAnimation * Math.PI / 10) * Math.PI / 4;
                    this.wing.rotation.z = angle;
                    this.wing.position.y = this.flapAnimation > 10 ? 0.1 : 0;
                    this.flapAnimation--;
                } else {
                    this.wing.rotation.z = 0;
                }

                // Head bobbing
                this.bobTime += 0.05;
                this.head.position.y = 0.2 + Math.sin(this.bobTime) * 0.05;

                // Update bounding sphere
                this.boundingSphere.center.copy(this.group.position);
            }
        }

        // Obstacle class
        class Obstacle {
            constructor(z) {
                this.group = new THREE.Group();
                this.passed = false;
                const gapCenter = THREE.MathUtils.randFloat(-4, 4 - TRUNK_GAP);
                // Bark material with shader
                const barkMat = new THREE.ShaderMaterial({
                    uniforms: THREE.UniformsUtils.clone(barkShader.uniforms),
                    vertexShader: barkShader.vertexShader,
                    fragmentShader: barkShader.fragmentShader
                });
                // Top trunk
                const topHeight = 10 - gapCenter;
                const topGeo = new THREE.CylinderGeometry(TRUNK_RADIUS, TRUNK_RADIUS, topHeight, 32);
                const topTrunk = new THREE.Mesh(topGeo, barkMat);
                topTrunk.position.set(0, (topHeight / 2) + (gapCenter + TRUNK_GAP), z);
                this.group.add(topTrunk);
                // Bottom trunk
                const bottomHeight = 10 + gapCenter;
                const bottomGeo = new THREE.CylinderGeometry(TRUNK_RADIUS, TRUNK_RADIUS, bottomHeight, 32);
                const bottomTrunk = new THREE.Mesh(bottomGeo, barkMat);
                bottomTrunk.position.set(0, -(bottomHeight / 2) + gapCenter, z);
                this.group.add(bottomTrunk);
                scene.add(this.group);
                this.z = z;
                this.boundingBoxes = [
                    new THREE.Box3().setFromObject(topTrunk),
                    new THREE.Box3().setFromObject(bottomTrunk)
                ];
                this.material = barkMat;
            }
            update() {
                this.z -= TRUNK_SPEED;
                this.group.position.z = this.z;
                this.material.uniforms.time.value += 0.01; // Animate noise slightly
                this.boundingBoxes[0].setFromObject(this.group.children[0]);
                this.boundingBoxes[1].setFromObject(this.group.children[1]);
            }
            destroy() {
                scene.remove(this.group);
                this.group.children.forEach(child => {
                    child.geometry.dispose();
                    child.material.dispose();
                });
            }
        }

        // Game setup
        async function init() {
            const turkey = new Turkey();
            const obstacles = [];
            let score = 0;
            let highScore = parseInt(localStorage.getItem('gobblyTurkeyHighScore')) || 0;
            let gameOver = false;
            const gameOverDiv = document.getElementById('gameOver');

            // Score display (3D text)
            const fontLoader = new FontLoader();
            let scoreText, highScoreText;
            const font = await fontLoader.loadAsync('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json');
            const createText = (text, posY) => {
                const textGeo = new TextGeometry(text, {
                    font: font,
                    size: 0.5,
                    depth: 0.1
                });
                const textMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
                const mesh = new THREE.Mesh(textGeo, textMat);
                mesh.position.set(-4, posY, 0);
                scene.add(mesh);
                return mesh;
            };
            scoreText = createText(`Turkeys Saved: ${score}`, 4);
            highScoreText = createText(`High Score: ${highScore}`, 3.5);

            // Update score text
            function updateScoreText() {
                if (scoreText) {
                    scoreText.geometry.dispose();
                    scoreText.geometry = new TextGeometry(`Turkeys Saved: ${score}`, {
                        font: font,
                        size: 0.5,
                        depth: 0.1
                    });
                }
                if (highScore < score) {
                    highScore = score;
                    localStorage.setItem('gobblyTurkeyHighScore', highScore);
                    if (highScoreText) {
                        highScoreText.geometry.dispose();
                        highScoreText.geometry = new TextGeometry(`High Score: ${highScore}`, {
                            font: font,
                            size: 0.5,
                            depth: 0.1
                        });
                    }
                }
            }

            // Event listeners
            document.addEventListener('keydown', (event) => {
                if (event.code === 'Space' && !gameOver) {
                    turkey.flap();
                }
                if (gameOver) {
                    window.location.reload();
                }
            });
            document.addEventListener('touchstart', () => {
                if (!gameOver) {
                    turkey.flap();
                }
            });

            // Spawn obstacles
            setInterval(() => {
                if (!gameOver) {
                    obstacles.push(new Obstacle(20));
                }
            }, TRUNK_FREQUENCY);

            // Game loop
            function animate() {
                if (gameOver) return;
                requestAnimationFrame(animate);

                // Update turkey
                turkey.update();

                // Update obstacles
                const toRemove = [];
                for (const obstacle of obstacles) {
                    obstacle.update();
                    if (!obstacle.passed && obstacle.z < turkey.group.position.z) {
                        score++;
                        obstacle.passed = true;
                        updateScoreText();
                    }
                    if (obstacle.z < -20) {
                        toRemove.push(obstacle);
                    }
                }
                toRemove.forEach(obstacle => {
                    const index = obstacles.indexOf(obstacle);
                    if (index > -1) obstacles.splice(index, 1);
                    obstacle.destroy();
                });

                // Collision detection (using bounding boxes)
                if (turkey.group.position.y > 6 || turkey.group.position.y < -6) {
                    endGame();
                }
                for (const obstacle of obstacles) {
                    if (obstacle.boundingBoxes.some(box => box.intersectsSphere(turkey.boundingSphere))) {
                        endGame();
                    }
                }

                renderer.render(scene, camera);
            }

            function endGame() {
                gameOver = true;
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('gobblyTurkeyHighScore', highScore);
                }
                gameOverDiv.style.display = 'block';
                gameOverDiv.innerHTML = `Turkey Down!<br>Turkeys Saved: ${score}<br>High Score: ${highScore}<br>Press any key or tap to try again`;
            }

            // Handle window resize for mobile
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }

        init();
    </script>
</body>
</html>
```

### Explanation of Fixes
1. **ES Module Import**:
   - Changed the script to use `<script type="module">` and imported Three.js via `import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.0/+esm'`.
   - Imported `FontLoader` and `TextGeometry` from `https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/...` to support 3D text.
   - This eliminates the `THREE is not defined` error and avoids the deprecated `build/three.min.js`.

2. **Font Loading**:
   - Used `FontLoader.loadAsync` to load the font asynchronously within the `init` function, ensuring the font is available before creating text.
   - Kept the same font URL for consistency (`helvetiker_regular.typeface.json`).

3. **Async Initialization**:
   - Wrapped the game logic in an `async init()` function to handle the asynchronous font loading, ensuring the game starts only after dependencies are ready.

4. **Preserved Features**:
   - Maintained all improvements: lighting (ambient and directional), procedural bark shader, high score with `localStorage`, touch input for mobile, wing rotation, head bobbing, and responsive window resizing.
   - Ensured collision detection, obstacle spawning, and game over mechanics remain intact.

### Running the Game
1. Save the code as `index.html`.
2. Serve it via a local server (e.g., `python -m http.server 8000`) to avoid CORS issues with ES Module imports.
3. Open `http://localhost:8000` in a browser (Chrome, Firefox, or similar).
4. Press the spacebar or tap (on mobile) to flap the turkey through gaps in the tree trunks.
5. On game over, press any key or tap to restart.

### Troubleshooting
If you encounter further issues:
- **CORS Errors**: Ensure you’re serving the file via a local server, as ES Modules require HTTP/HTTPS for external imports.
- **Font Loading Failure**: Verify internet connectivity, as the font is loaded from `threejs.org`. Alternatively, I can provide a version with 2D canvas text to avoid font dependency.
- **Performance**: If the game lags, reduce geometry complexity (e.g., lower `segments` in `SphereGeometry` or `CylinderGeometry`).
- **Mobile Issues**: Test touch input on a mobile device; if it fails, I can debug the `touchstart` event further.

Please test this updated code and let me know if you encounter any issues or want additional tweaks (e.g., simplifying text rendering, adding a skybox, or adjusting gameplay parameters)!